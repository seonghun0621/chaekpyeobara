# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uhzqdVLIgx-RNuF9vtIOqQr0crUY1g7W
"""

import streamlit as st
import requests
import re
import json
import openai
from datetime import datetime
import random
    
# ì•Œë¼ë”˜ API ì¸ì¦í‚¤
TTB_KEY = "ttbtmdwn021442001"


# ì±… ê²€ìƒ‰ í•¨ìˆ˜
def search_book(book_title):
    search_url = "http://www.aladin.co.kr/ttb/api/ItemSearch.aspx"
    params = {
        "ttbkey": TTB_KEY,
        "Query": book_title,
        "QueryType": "Title",
        "MaxResults": 1,
        "SearchTarget": "Book",
        "output": "js",
        "Version": "20131101"
    }
    response = requests.get(search_url, params=params)
    data = response.json()

    if "item" in data and len(data["item"]) > 0:
        book = data["item"][0]
        book_info = {
            "title": book.get("title", "ì œëª© ì •ë³´ ì—†ìŒ"),
            "author": book.get("author", "ì €ì ì •ë³´ ì—†ìŒ"),
            "publisher": book.get("publisher", "ì¶œíŒì‚¬ ì •ë³´ ì—†ìŒ"),
            "price": book.get("priceStandard", "ê°€ê²© ì •ë³´ ì—†ìŒ"),
            "isbn": book.get("isbn13", None)
        }

        if book_info["isbn"]:
            lookup_url = "http://www.aladin.co.kr/ttb/api/ItemLookUp.aspx"
            lookup_params = {
                "ttbkey": TTB_KEY,
                "itemIdType": "ISBN",
                "ItemId": book_info["isbn"],
                "output": "js",
                "Version": "20131101"
            }
            lookup_response = requests.get(lookup_url, params=lookup_params)
            lookup_data = lookup_response.json()

            if "item" in lookup_data and len(lookup_data["item"]) > 0:
                details = lookup_data["item"][0]
                book_info["page_count"] = details.get("subInfo", {}).get("itemPage", "ìª½ìˆ˜ ì •ë³´ ì—†ìŒ")
            else:
                book_info["page_count"] = "ìª½ìˆ˜ ì •ë³´ ì—†ìŒ"
        else:
            book_info["page_count"] = "ìª½ìˆ˜ ì •ë³´ ì—†ìŒ"

        return book_info
    else:
        return {"error": "ì±… ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”."}

# ëª©í‘œ ì½ê¸° ê³„íš ìƒì„± í•¨ìˆ˜
def calculate_daily_pages(total_pages, target_days):
    try:
        daily_pages = total_pages // target_days
        remaining_pages = total_pages % target_days
        return daily_pages, remaining_pages
    except ZeroDivisionError:
        return 0, 0

# ëª©í‘œë¥¼ ì¬ì¡°ì •í•˜ëŠ” í•¨ìˆ˜
def recalculate_goal_dynamic(remaining_pages, pages_read_today, remaining_days):
    remaining_pages -= pages_read_today
    if remaining_pages <= 0:
        return remaining_pages, 0, 0, "ì±…ì„ ë‹¤ ì½ì—ˆì–´ìš”!"
    
    new_daily_goal = remaining_pages // remaining_days
    remaining_days -= 1
    
    return remaining_pages, new_daily_goal, remaining_days, f"ë‚¨ì€ ëª©í‘œ ì¼ìˆ˜ëŠ” {remaining_days}ì¼ì´ì—ìš”."
    
# ëª©í‘œ ì €ì¥í•˜ê¸°
def save_goal(book_title, target_days, daily_pages, remaining_pages):
    goal_data = {
        "book_title": book_title,
        "target_days": target_days,
        "daily_pages": daily_pages,
        "remaining_pages": remaining_pages,
        "date_completed": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    }
    try:
        with open("reading_goals.json", "a", encoding="utf-8") as file:
            existing_data = load_goals()
            existing_data.append(goal_data)
            with open("reading_goals.json", "w", encoding="utf-8") as write_file:
                json.dump(existing_data, write_file, ensure_ascii=False, indent=4)
            st.write("ğŸ“‚ ëª©í‘œê°€ ì„±ê³µì ìœ¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!")
    except Exception as e:
        st.write(f"ì €ì¥ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")

def load_goals():
    try:
        with open("reading_goals.json", "r", encoding="utf-8") as file:
            goals = json.load(file)
            if isinstance(goals, list):
                return goals
            else:
                return []
    except Exception as e:
        st.write(f"ëª©í‘œ ë¶ˆëŸ¬ì˜¤ê¸° ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        return []

def initialize_file():
    try:
        with open("reading_goals.json", "r", encoding="utf-8") as file:
            pass
    except FileNotFoundError:
        with open("reading_goals.json", "w", encoding="utf-8") as file:
            json.dump([], file, ensure_ascii=False, indent=4)

initialize_file()

def give_challenge(book_title):
    st.write(f"ğŸ¯ **{book_title}** ì±…ì„ ë‹¤ ì½ì€ ê²ƒì„ ì¶•í•˜ë“œë ¤ìš”! ğŸ¦¦")
    st.write("ìƒˆë¡œìš´ ë„ì „ ê³¼ì œë¥¼ ì œê³µí•©ë‹ˆë‹¤!")
    st.write("ë‹¤ìŒ ë„ì „ì€ ë¬´ì—‡ì¸ê°€ìš”? ë‹¤ì‹œ ëª©í‘œë¥¼ ì„¤ì •í•´ë³¼ê¹Œìš”? ğŸ¾")

st.set_page_config(page_title="ì±…í´ë°”ë¼ - ìˆ²ì† ë„ì„œê´€", layout="wide")
st.title("ì±…í´ë°”ë¼ ìˆ²ì† ë„ì„œê´€ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤! ğŸ¦¦ğŸ“š")

tab1, tab2, tab3, tab4 = st.tabs(["ì±… ê²€ìƒ‰ ë° ëª©í‘œ ì„¤ì •", "ë…ì„œ ê°ìƒë¬¸ ì“°ê¸°", "ë…ì„œ ê°ìƒ ì£¼ê³ ë°›ê¸°", "ì±… ì¶”ì²œë°›ê¸°"])

import time

with tab1:
    book_title = st.text_input("ê²€ìƒ‰í•  ì±… ì œëª©ì„ ì…ë ¥í•˜ì„¸ìš”:")

    if book_title:
        book_info = search_book(book_title)

        if "error" not in book_info:
            st.write(f"ì±… ì´ë¦„: **'{book_info['title']}'**")
            st.write(f"ì§€ì€ì´: **{book_info['author']}**")
            st.write(f"ì¶œíŒì‚¬: **{book_info['publisher']}**")
            st.write(f"ê°€ê²©: **{book_info['price']}ì›**")
            st.write(f"ìª½ìˆ˜: **{book_info['page_count']}ìª½**")
        else:
            st.write(book_info["error"])

        target_days_input = st.text_input("\nëª©í‘œ ì½ê¸° ê¸°ê°„(ì¼)ì„ ì…ë ¥í•´ì£¼ì„¸ìš”:")
        if target_days_input:
            target_days = int(re.sub(r'\D', '', target_days_input))
            daily_pages, remaining_pages = calculate_daily_pages(int(book_info["page_count"]), target_days)

            st.write(f"í•˜ë£¨ì— **{daily_pages}ìª½**ì”© ì½ìœ¼ë©´ ë©ë‹ˆë‹¤.")
            if remaining_pages > 0:
                st.write(f"ë§ˆì§€ë§‰ ë‚  ì¶”ê°€ë¡œ ì½ì–´ì•¼ í•  í˜ì´ì§€: **{remaining_pages}ìª½**")
            st.write("ì˜¤ëŠ˜ë¶€í„° ì‹œì‘í•´ë³¼ê¹Œìš”?")

            # ìƒíƒœ ì´ˆê¸°í™”
            if "remaining_pages" not in st.session_state:
                st.session_state.remaining_pages = int(book_info["page_count"])
                st.session_state.remaining_days = target_days
                st.session_state.daily_goal = daily_pages

            # í˜„ì¬ ìƒíƒœ í‘œì‹œ
            st.write(f"ë‚¨ì€ í˜ì´ì§€: {st.session_state.remaining_pages}ìª½")
            st.write(f"í•˜ë£¨ ëª©í‘œ í˜ì´ì§€: {st.session_state.daily_goal}ìª½")
            st.write(f"ë‚¨ì€ ëª©í‘œ ì¼ìˆ˜: {st.session_state.remaining_days}ì¼")

            # ì˜¤ëŠ˜ ì½ì€ í˜ì´ì§€ ìˆ˜ ì…ë ¥
            key = f"pages_read_{int(time.time())}"  # ê³ ìœ í•œ key ìƒì„±
            pages_read_today = st.number_input(
                f"ì˜¤ëŠ˜ ì½ì€ í˜ì´ì§€ ìˆ˜ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš” (ë‚¨ì€ í˜ì´ì§€: {st.session_state.remaining_pages}):",
                min_value=0,
                max_value=st.session_state.remaining_pages,
                key=key,
            )

            # ì§„í–‰ ì—…ë°ì´íŠ¸ ë²„íŠ¼
            if st.button("ì§„í–‰ ì—…ë°ì´íŠ¸"):
                if pages_read_today > 0:
                    (
                        st.session_state.remaining_pages,
                        st.session_state.daily_goal,
                        st.session_state.remaining_days,
                        status,
                    ) = recalculate_goal_dynamic(
                        st.session_state.remaining_pages,
                        pages_read_today,
                        st.session_state.remaining_days,
                    )

                    if st.session_state.remaining_pages == 0:
                        st.write("ìš°ì™€~! ğŸ¦¦ ì±…ì„ ë‹¤ ì½ì—ˆì–´ìš”! ğŸ‰")
                        save_goal(
                            book_info["title"],
                            target_days,
                            daily_pages,
                            st.session_state.remaining_pages,
                        )
                        give_challenge(book_info["title"])
                    else:
                        st.write(f"ë‚¨ì€ í˜ì´ì§€: {st.session_state.remaining_pages}ìª½")
                        st.write(
                            f"ë‚´ì¼ë¶€í„° í•˜ë£¨ ëª©í‘œëŠ” {st.session_state.daily_goal}ìª½ì…ë‹ˆë‹¤."
                        )
                        st.write(f"ë‚¨ì€ ëª©í‘œ ì¼ìˆ˜: {st.session_state.remaining_days}ì¼")
        else:
            st.write("ëª©í‘œ ì½ê¸° ê¸°ê°„ì„ ì…ë ¥í•´ ì£¼ì„¸ìš”!")

        st.write("ğŸ“… ì§€ë‚œ ëª©í‘œ í™•ì¸í•˜ê¸°:")
        goals = load_goals()

        if goals:
            for goal in goals:
                st.write(f"ğŸ“– ì±… ì œëª©: {goal['book_title']}")
                st.write(f"ğŸ“… ëª©í‘œ ê¸°ê°„: {goal['target_days']}ì¼")
                st.write(f"ğŸ“˜ í•˜ë£¨ ëª©í‘œ í˜ì´ì§€: {goal['daily_pages']}í˜ì´ì§€")
                st.write(f"ğŸ“š ë‚¨ì€ í˜ì´ì§€: {goal['remaining_pages']}í˜ì´ì§€")
                st.write(f"âœ… ì™„ë£Œì¼: {goal['date_completed']}")
                st.write("---")
        else:
            st.write("ì €ì¥ëœ ëª©í‘œê°€ ì—†ìŠµë‹ˆë‹¤.")

            
# ëª©í‘œ ë¶ˆëŸ¬ì˜¤ê¸°
goals = load_goals()  # ì—¬ê¸°ì— ëª©í‘œë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì½”ë“œê°€ í•„ìš”
with tab2:
    st.subheader("ğŸ“š ìƒˆ ë„ì „ ê³¼ì œ & ê°ìƒë¬¸ ê¸°ë¡")
    
    # ê°ìƒë¬¸ ì‘ì„± ê¸°ëŠ¥
    st.write("ì½ì€ ì±…ì— ëŒ€í•œ ê°ìƒë¬¸ì„ ì‘ì„±í•˜ê³  ê³µìœ í•´ë³´ì„¸ìš”!")
    selected_goal_title = st.selectbox(
    "ê°ìƒë¬¸ì„ ì‘ì„±í•  ì±…ì„ ì„ íƒí•˜ì„¸ìš”:", 
    [goal['book_title'] for goal in goals] if goals else []
    )
    review_text = st.text_area("ê°ìƒë¬¸ì„ ì—¬ê¸°ì— ì‘ì„±í•˜ì„¸ìš”:", height=200)
    if st.button("ê°ìƒë¬¸ ì €ì¥í•˜ê¸°"):
        if selected_goal_title and review_text.strip():
            try:
                # ê°ìƒë¬¸ ì €ì¥
                reviews_file = "reading_reviews.json"
                try:
                    with open(reviews_file, "r", encoding="utf-8") as file:
                        reviews = json.load(file)
                except (FileNotFoundError, json.JSONDecodeError):
                    reviews = []
                
                reviews.append({
                    "book_title": selected_goal_title,
                    "review": review_text,
                    "date_written": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                })
                with open(reviews_file, "w", encoding="utf-8") as file:
                    json.dump(reviews, file, ensure_ascii=False, indent=4)
                st.success("ğŸ“– ê°ìƒë¬¸ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤! ì˜í–ˆì–´ìš”! ğŸ¦¦")
            except Exception as e:
                st.error(f"ê°ìƒë¬¸ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {e}")
        else:
            st.warning("ì±… ì œëª©ê³¼ ê°ìƒë¬¸ì„ ì…ë ¥í•´ ì£¼ì„¸ìš”!")

    # ì €ì¥ëœ ê°ìƒë¬¸ ë¶ˆëŸ¬ì˜¤ê¸°
    st.write("ğŸ“– ë‚´ê°€ ì‘ì„±í•œ ê°ìƒë¬¸:")
    try:
        with open("reading_reviews.json", "r", encoding="utf-8") as file:
            reviews = json.load(file)
        if reviews:
            for review in reviews:
                st.write(f"ğŸ“š ì±… ì œëª©: {review['book_title']}")
                st.write(f"ğŸ“ ê°ìƒë¬¸: {review['review']}")
                st.write(f"ğŸ“… ì‘ì„±ì¼: {review['date_written']}")
                st.write("---")
        else:
            st.write("ì‘ì„±ëœ ê°ìƒë¬¸ì´ ì—†ìŠµë‹ˆë‹¤.")
    except (FileNotFoundError, json.JSONDecodeError):
        st.write("ì‘ì„±ëœ ê°ìƒë¬¸ì´ ì—†ìŠµë‹ˆë‹¤.")

    # ìƒˆë¡œìš´ ë„ì „ ê³¼ì œ ì œê³µ
    st.write("ğŸ¯ ìƒˆë¡œìš´ ë„ì „ ê³¼ì œ")
    st.write("ì½ì€ ì±…ì„ ë°”íƒ•ìœ¼ë¡œ ìƒˆë¡œìš´ ëª©í‘œë¥¼ ì„¤ì •í•´ë³´ì„¸ìš”!")
    new_challenge_title = st.text_input("ìƒˆë¡œìš´ ë„ì „ ê³¼ì œë¥¼ ì…ë ¥í•˜ì„¸ìš”:")
    challenge_deadline = st.date_input("ëª©í‘œ ë§ˆê°ì¼ì„ ì„¤ì •í•˜ì„¸ìš”:")
    if st.button("ë„ì „ ê³¼ì œ ì €ì¥í•˜ê¸°"):
        try:
            # ë„ì „ ê³¼ì œ ì €ì¥
            challenges_file = "reading_challenges.json"
            try:
                with open(challenges_file, "r", encoding="utf-8") as file:
                    challenges = json.load(file)
            except (FileNotFoundError, json.JSONDecodeError):
                challenges = []
            
            challenges.append({
                "challenge": new_challenge_title,
                "deadline": challenge_deadline.strftime("%Y-%m-%d"),
                "date_created": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            })
            with open(challenges_file, "w", encoding="utf-8") as file:
                json.dump(challenges, file, ensure_ascii=False, indent=4)
            st.success("ğŸ¯ ë„ì „ ê³¼ì œê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!")
        except Exception as e:
            st.error(f"ë„ì „ ê³¼ì œ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {e}")

    # ì €ì¥ëœ ë„ì „ ê³¼ì œ ë¶ˆëŸ¬ì˜¤ê¸°
    st.write("ğŸ“Œ ì €ì¥ëœ ë„ì „ ê³¼ì œ:")
    try:
        with open("reading_challenges.json", "r", encoding="utf-8") as file:
            challenges = json.load(file)
        if challenges:
            for challenge in challenges:
                st.write(f"ğŸ”– ë„ì „ ê³¼ì œ: {challenge['challenge']}")
                st.write(f"â³ ë§ˆê°ì¼: {challenge['deadline']}")
                st.write(f"ğŸ“… ìƒì„±ì¼: {challenge['date_created']}")
                st.write("---")
        else:
            st.write("ì €ì¥ëœ ë„ì „ ê³¼ì œê°€ ì—†ìŠµë‹ˆë‹¤.")
    except (FileNotFoundError, json.JSONDecodeError):
        st.write("ì €ì¥ëœ ë„ì „ ê³¼ì œê°€ ì—†ìŠµë‹ˆë‹¤.")

# ì•Œë¼ë”˜ API ê²€ìƒ‰ í•¨ìˆ˜ (ì˜ˆì‹œë¡œ ê°„ë‹¨íˆ ì‘ì„±)
def search_book(book_title):
    # ì—¬ê¸°ì— ì•Œë¼ë”˜ API í˜¸ì¶œ ì½”ë“œ ì¶”ê°€ (ì˜ˆì‹œë¡œ ê°„ë‹¨í•œ ì‘ë‹µ ë°˜í™˜)
    # ì‹¤ì œ API í˜¸ì¶œì„ êµ¬í˜„í•˜ë ¤ë©´ í•´ë‹¹ APIì˜ ë¬¸ì„œë¥¼ ì°¸ê³ í•˜ì„¸ìš”.
    try:
        # ì˜ˆì‹œ: ì±… ì •ë³´ë¥¼ ë°˜í™˜ (APIë¥¼ í†µí•´ ì‹¤ì œ ì±… ì •ë³´ë¥¼ ë°›ì•„ì˜¬ ë¶€ë¶„)
        book_info = {
            "title": book_title,
            "author": "ì €ìëª…",
            "publisher": "ì¶œíŒì‚¬ëª…",
            "price": 20000,
            "isbn": "978-1234567890",
            "description": "ì±…ì— ëŒ€í•œ ê°„ë‹¨í•œ ì„¤ëª…"
        }
        return book_info
    except Exception as e:
        return {"error": f"ì±… ì •ë³´ë¥¼ ê°€ì ¸ì˜¤ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: {e}"}

# ChatGPTì™€ ëŒ€í™”í•˜ëŠ” í•¨ìˆ˜
def chat_with_gpt(book_title, user_feedback):
    prompt = f"ì±… ì œëª©: {book_title}\nê°ìƒë¬¸: {user_feedback}\nChatGPTì—ê²Œ ì§ˆë¬¸: ì´ ì±…ì— ëŒ€í•´ ì–´ë–»ê²Œ ìƒê°í•˜ë‚˜ìš”?"
    
    response = openai.Completion.create(
        model="text-davinci-003",  # ë˜ëŠ” ì‚¬ìš©í•˜ê³ ì í•˜ëŠ” ëª¨ë¸
        prompt=prompt,
        max_tokens=100
    )
    
    return response.choices[0].text.strip()

import openai
with open("apikey.json", "r") as file:
    api_keys = json.load(file)

open_api_key = api_keys.get("open_api_key")
    
# íƒ­ 3 - ì•Œë¼ë”˜ APIì™€ ChatGPT í†µí•©
with tab3:
    st.subheader("ğŸ¤– ì±… ì •ë³´ ê²€ìƒ‰ & ChatGPTì™€ ëŒ€í™”")

    # ì‚¬ìš©ì ì…ë ¥
    book_title = st.text_input("ğŸ“š ì±… ì œëª©ì„ ì…ë ¥í•˜ì„¸ìš”:")
    user_feedback = st.text_area("âœï¸ ì´ ì±…ì— ëŒ€í•œ ê°ìƒì„ ì…ë ¥í•˜ì„¸ìš”:")

    if st.button("ğŸ” ì±… ê²€ìƒ‰ ë° ëŒ€í™” ì‹œì‘"):
        if book_title.strip() == "":
            st.warning("ì±… ì œëª©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”!")
        elif user_feedback.strip() == "":
            st.warning("ì±…ì— ëŒ€í•œ ê°ìƒì„ ì…ë ¥í•´ì£¼ì„¸ìš”!")
        else:
            try:
                # ì•Œë¼ë”˜ APIë¥¼ í†µí•´ ì±… ì •ë³´ ê°€ì ¸ì˜¤ê¸°
                book_info = search_book(book_title)

                if "error" in book_info:
                    st.error(book_info["error"])
                else:
                    # ì±… ì •ë³´ ì¶œë ¥
                    st.write("ğŸ“– **ì±… ì •ë³´**")
                    st.write(f"- **ì œëª©:** {book_info['title']}")
                    st.write(f"- **ì €ì:** {book_info['author']}")
                    st.write(f"- **ì¶œíŒì‚¬:** {book_info['publisher']}")
                    st.write(f"- **ê°€ê²©:** {book_info['price']}ì›")
                    st.write(f"- **ISBN:** {book_info['isbn']}")
                    st.write(f"- **ì¤„ê±°ë¦¬:** {book_info['description']}")

                    # JSON íŒŒì¼ ì €ì¥
                    with open("book_info.json", "w", encoding="utf-8") as file:
                        json.dump(book_info, file, ensure_ascii=False, indent=4)
                    st.success("ğŸ“‚ ì±… ì •ë³´ë¥¼ 'book_info.json'ì— ì €ì¥í–ˆìŠµë‹ˆë‹¤!")

                    # ChatGPTì™€ ëŒ€í™” ì‹œì‘
                    gpt_response = chat_with_gpt(book_title, user_feedback)
                    st.write("ğŸ¤– **ChatGPTì˜ ëŒ€ë‹µ**")
                    st.write(gpt_response)

            except Exception as e:
                st.error(f"ì˜¤ë¥˜ ë°œìƒ: {e}")




# íƒ­ 4 - ì±… ì¶”ì²œë°›ê¸°
with tab4:
    st.subheader("ğŸ¦« ì±…í´ë°”ë¼ì—ê²Œ ì±… ì¶”ì²œë°›ê¸° ğŸ“–")
    #ì‚¬ìš©ì ì…ë ¥ë°›ê¸°
    gender = st.selectbox("ì„±ë³„ì„ ì„ íƒí•˜ì„¸ìš”", ["ë‚¨ì„±", "ì—¬ì„±", "ë¯¸ìƒ"])
    age = st.selectbox("ë‚˜ì´ë¥¼ ì„ íƒí•˜ì„¸ìš”", ["ì˜ìœ ì•„", "ìœ ì•„", "ì´ˆë“±", "ì²­ì†Œë…„", "20ëŒ€", "30ëŒ€", "40ëŒ€", "50ëŒ€", "60ì„¸ ì´ìƒ", "ë¯¸ìƒ"])
    major_topic = st.selectbox("ê´€ì‹¬ ëŒ€ì£¼ì œë¥¼ ì„ íƒí•˜ì„¸ìš”", ["ì´ë¥˜", "ì² í•™", "ì¢…êµ", "ì‚¬íšŒê³¼í•™", "ìì—°ê³¼í•™", "ê¸°ìˆ ê³¼í•™", "ì˜ˆìˆ ", "ì–¸ì–´", "ë¬¸í•™", "ì—­ì‚¬"])
    region = st.selectbox("ì§€ì—­ì„ ì„ íƒí•˜ì„¸ìš”", ["ì„œìš¸", "ë¶€ì‚°", "ëŒ€êµ¬", "ì¸ì²œ", "ê´‘ì£¼", "ëŒ€ì „", "ìš¸ì‚°", "ì„¸ì¢…", "ê²½ê¸°", "ê°•ì›", "ì¶©ë¶", "ì¶©ë‚¨", "ì „ë¶", "ì „ë‚¨", "ê²½ë¶", "ê²½ë‚¨", "ì œì£¼"])

    #ë„ì„œê´€ ì •ë³´ë‚˜ë£¨ API ì¸ì¦í‚¤
    LIB_KEY = "661a88b506497d2578c01548eb504b824b8fe475c0d9a08379b712caf9577067"
    
    # ì½”ë“œ ë§¤í•‘
    gender_map = {"ë‚¨ì„±": 0, "ì—¬ì„±": 1, "ë¯¸ìƒ": 2}
    age_map = {"ì˜ìœ ì•„": 0, "ìœ ì•„": 6, "ì´ˆë“±": 8, "ì²­ì†Œë…„": 14, "20ëŒ€": 20, "30ëŒ€": 30, "40ëŒ€": 40, "50ëŒ€": 50, "60ì„¸ ì´ìƒ": 60, "ë¯¸ìƒ": -1}
    major_topic_map = {"ì´ë¥˜": 0, "ì² í•™": 1, "ì¢…êµ": 2, "ì‚¬íšŒê³¼í•™": 3, "ìì—°ê³¼í•™": 4, "ê¸°ìˆ ê³¼í•™": 5, "ì˜ˆìˆ ": 6, "ì–¸ì–´": 7, "ë¬¸í•™": 8, "ì—­ì‚¬": 9}
    region_map = {"ì„œìš¸": 11, "ë¶€ì‚°": 21, "ëŒ€êµ¬": 22, "ì¸ì²œ": 23, "ê´‘ì£¼": 24, "ëŒ€ì „": 25, "ìš¸ì‚°": 26, "ì„¸ì¢…": 29, "ê²½ê¸°": 31, "ê°•ì›": 32, "ì¶©ë¶": 33, "ì¶©ë‚¨": 34, "ì „ë¶": 35, "ì „ë‚¨": 36, "ê²½ë¶": 37, "ê²½ë‚¨": 38, "ì œì£¼": 39}
    
    # ë³€í™˜
    selected_gender = gender_map[gender]
    selected_age = age_map[age]
    selected_major_topic = major_topic_map[major_topic]
    selected_region = region_map[region]
    
    #API í˜¸ì¶œ
    def fetch_books(api_key, gender, age, region, major_topic):
        url = "http://data4library.kr/api/loanItemSrchByLib"
        params = {
            "authKey": LIB_KEY,
            "gender": gender,
            "age": age,
            "region": region,
            "kdc": major_topic,
            "format": "json",
            "pageSize": 10
        }
    
        response = requests.get(url, params=params)
        if response.status_code == 200:
            data = response.json()
            docs = data.get("response", {}).get("docs", [])  # `response` > `docs`
            
            # `docs` ë¦¬ìŠ¤íŠ¸ì—ì„œ `doc` í‚¤ ë°ì´í„°ë¥¼ ì¶”ì¶œ
            books = [item["doc"] for item in docs if "doc" in item]
            return books
        else:
            st.error(f"API í˜¸ì¶œ ì‹¤íŒ¨: {response.status_code}")
            return []
    
    #ì¶”ì²œë„ì„œ ëœë¤ 3ê¶Œ ì„ íƒ
    def recommend_books(books):
        if len(books) == 0:
            st.warning("ì¡°ê±´ì— ë§ëŠ” ë„ì„œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
            return []
    
        # ëœë¤ìœ¼ë¡œ 3ê¶Œ ì„ íƒ
        selected_books = random.sample(books, min(3, len(books)))
        return selected_books
    
    def generate_recommendation_reason(selected_books):
        titles = ", ".join([book["bookname"] for book in selected_books])
        prompt = f"""
        ì‚¬ìš©ìê°€ ì„ íƒí•œ ì¡°ê±´ì— ë§ëŠ” ë„ì„œ '{titles}'ë¥¼ ì¶”ì²œí•©ë‹ˆë‹¤.
        ê° ë„ì„œê°€ ì™œ ì¶”ì²œë˜ì—ˆëŠ”ì§€ ê°„ë‹¨íˆ ì„¤ëª…í•´ì£¼ì„¸ìš”.
        """
        response = openai.Completion.create(
            model="gpt-3.5-turbo",
            prompt=prompt,
            max_tokens=300
        )
        return response.choices[0].text.strip()
    
    def generate_recommendation_reason(selected_books):
        titles = ", ".join([book["bookname"] for book in selected_books])
        prompt = f"""
        ë‹¤ìŒ ë„ì„œë“¤ì„ ì‚¬ìš©ìê°€ ì„ íƒí•œ ì¡°ê±´ì— ë”°ë¼ ì¶”ì²œí•©ë‹ˆë‹¤:
        '{titles}'.
        ê° ë„ì„œê°€ ì™œ ì¶”ì²œë˜ì—ˆëŠ”ì§€ ê°„ë‹¨íˆ ì„¤ëª…í•´ì£¼ì„¸ìš”.
        """
        try:
            response = openai.Completion.create(
                model="gpt-3.5-turbo",  # ì˜¬ë°”ë¥¸ ëª¨ë¸ ì´ë¦„ ì‚¬ìš©
                prompt=prompt,
                max_tokens=300
            )
            return response.choices[0].text.strip()
        except openai.error.OpenAIError as e:
            st.error(f"OpenAI API í˜¸ì¶œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {str(e)}")
            return "ì¶”ì²œ ì´ìœ ë¥¼ ìƒì„±í•˜ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤."
    
    if st.button("ì±… ì¶”ì²œë°›ê¸°"):
        # API í˜¸ì¶œ
        books = fetch_books(LIB_KEY, selected_gender, selected_age, selected_region, selected_major_topic)
    
        if books:
            # ì¶”ì²œ ë„ì„œ ì„ íƒ
            selected_books = recommend_books(books)
    
            if selected_books:
                st.write("ì¶”ì²œ ë„ì„œ ëª©ë¡:")
                for book in selected_books:
                    st.markdown(f"< {book['bookname']} >")
                    st.markdown(f"  ğŸ§‘â€ğŸ’»ì €ìğŸ§‘â€ğŸ’»: {book['authors']}  \n"  
                            f"  ğŸ¢ì¶œíŒì‚¬ğŸ¢: {book['publisher']}  \n"
                            f"  â³ì¶œíŒë…„ë„âŒ›ï¸: {book['publication_year']}")
                    st.image(book.get("bookImageURL", ""), width=100)  # ì±… ì´ë¯¸ì§€ ì¶œë ¥
                    st.write(f"[ğŸ“–ì±… ì •ë³´ ìƒì„¸ í˜ì´ì§€ë¡œ ì´ë™í•˜ê¸°ğŸ“–]({book['bookDtlUrl']})")
                    st.markdown("---")
                
                # ì¶”ì²œ ì´ìœ  ìƒì„±
                reason = generate_recommendation_reason(selected_books)
                st.write("**ì¶”ì²œ ì´ìœ :**")
                st.write(reason)
            else:
                st.warning("ì¶”ì²œ ë„ì„œê°€ ì—†ìŠµë‹ˆë‹¤.")
        else:
            st.warning("ì¡°ê±´ì— ë§ëŠ” ë„ì„œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
